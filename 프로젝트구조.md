# Base Module Driven Monorepo

이 저장소는 **BaseModule**을 중심으로 모든 NestJS 모듈에 동일한 패턴을 강제합니다. 각 도메인 모듈은 Base 레이어를 상속해 공통 기능(응답 포맷, CRUD, 저장소 계약 등)을 그대로 재사용하면서 도메인 고유 로직만 구현합니다.

---

## 📦 프로젝트 전체 구조

```
.
├── base/                # 공통 BaseModule + Controller/Service/Repository
├── auth/                # 인증 도메인 모듈
├── user/                # 사용자 도메인 모듈
├── schedule/            # 일정 도메인 모듈
├── notification/        # 알림 도메인 모듈
├── label/               # 라벨 도메인 모듈
├── admin/               # 어드민 도메인 모듈
├── package.json         # 워크스페이스 정의 + dev 스크립트
├── tsconfig.base.json   # TypeScript 공통(base alias 포함)
└── setup.js             # 모듈/레이어 자동 스캐폴딩
```

### base/가 제공하는 것

| 파일/클래스                                    | 설명 |
| ---------------------------------------------- | ---- |
| `BaseModule` (`base/src/app/base.module.ts`)   | 모든 모듈이 상속. 모듈 초기화/로깅 등 공통 처리 |
| `BaseController` (`base/src/interface/...`)    | `success()/failure()` 응답 규격 제공 |
| `BaseService`, `BaseRepository`                | CRUD/조회 기본 메서드 제공 |
| `BaseInMemoryRepository`                       | 초기 개발용 메모리 저장소 |
| `BaseUseCase`, `BaseEntity`, `BaseResponse`    | 유스케이스/엔티티/DTO 기본 형태 정의 |

### 각 도메인 모듈 구조

```
module/
├── app/                # BaseModule 확장, main.ts 부트스트랩
├── interface/          # BaseController 상속 컨트롤러
├── application/        # BaseService 상속 서비스/유스케이스
├── domain/             # BaseEntity 확장 모델
├── infrastructure/     # BaseRepository 구현체 (in-memory → DB 교체 가능)
└── shared/             # DTO/상수/유틸
```

의존 방향은 **base → app → interface → application → domain → infrastructure** 만 허용하여 관심사를 분리합니다.

---

## 🚀 실행 & 개발 워크플로우

### 1. 설치 & 공통 스캐폴드

```bash
npm install            # 모든 워크스페이스 의존성 설치
node setup.js          # (선택) 새 모듈/레이어 뼈대 생성
```

### 2. 모듈 개별 실행

```bash
npm run dev:auth       # AUTH_PORT (기본 3010)에서 서버 시작
npm run dev:user       # USER_PORT (기본 3020)
# 필요 모듈만 선택해서 실행
```

각 모듈 폴더에서도 `npm run start:dev`로 단독 실행 가능합니다. 컨트롤러는 공통 `success()` 응답 포맷을 사용하며, 서비스는 BaseService 덕분에 CRUD 메서드를 바로 활용합니다.

### 3. 통합 실행 예시

Gateway 없이도 하나의 Nest 앱에서 여러 모듈을 묶고 싶다면, 예를 들어 `apps/api`를 추가해 다음과 같이 구성합니다.

```ts
// apps/api/app/api.module.ts
@Module({
  imports: [AuthModule, UserModule, ScheduleModule, ...],
})
export class ApiModule extends BaseModule {
  protected moduleName = 'ApiModule';
}
```

```ts
// apps/api/app/main.ts
async function bootstrap() {
  const app = await NestFactory.create(ApiModule);
  await app.listen(process.env.API_PORT ?? 4000);
}
```

이처럼 BaseModule을 상속하는 단일 진입점을 원하는 곳에서 만들면, 별도 gateway 패키지 없이도 통합 실행을 할 수 있습니다.

---

## 🧪 예시 개발 플로우 (Auth 모듈)

1. **도메인 정의**  
   - `auth/domain/models/auth-greeting.entity.ts`에서 `BaseEntity`를 확장.
2. **저장소 구현**  
   - `auth/infrastructure/auth.repository.ts`에서 `BaseInMemoryRepository` 상속 → 샘플 데이터 시드.
3. **서비스 작성**  
   - `auth/application/services/auth.service.ts`에서 `BaseService` 상속 후, `getGreeting()` 같은 도메인 로직 추가.
4. **컨트롤러 작성**  
   - `auth/interface/http/auth.controller.ts`에서 `BaseController.success()`를 이용해 응답.
5. **모듈 선언 & 부트스트랩**  
   - `auth/app/auth.module.ts`에서 BaseModule 상속, `auth/app/main.ts`에서 NestFactory 실행.
6. **실행 확인**  
   - `npm run dev:auth` 후 `GET /auth/hello` 호출 → `{ success: true, data: { ... } }` 응답 확인.

다른 모듈도 동일한 흐름으로 개발하며, Base 계층 덕분에 CRUD/응답/에러 처리 패턴이 자동으로 통일됩니다.

---

## ✅ 운영 팁

- Base 클래스를 변경하면 모든 모듈에 즉시 반영되므로, 로깅/에러 처리/응답 포맷을 한 곳에서 통제할 수 있습니다.
- `infrastructure/`를 InMemory에서 Prisma 등 실제 DB 어댑터로 교체해도, `BaseRepository` 계약만 지키면 application/domain 코드를 바꾸지 않고 확장 가능합니다.
- 통합 테스트나 E2E 테스트를 작성할 때는, BaseModule을 확장한 통합 `ApiModule`(또는 필요 시 별도 gateway)을 기준으로 시나리오를 구성하는 것이 좋습니다.

이 구조를 기반으로 도메인 모듈을 계속 추가하거나 확장하면, **공통 로직 강제 + 개발 생산성 + 코드 일관성**을 동시에 만족하는 아키텍처를 유지할 수 있습니다.
